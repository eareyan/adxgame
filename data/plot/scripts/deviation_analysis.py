#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 23 10:58:01 2017

@author: enriqueareyan
"""
import deviation_graphs
import deviation_analysis
import zipfile
import setup
import networkx as nx
import pandas as pd
from itertools import chain

def get_agreement_data(G1, G2):
    """
    Given a pair of deviation graphs G1, G2, returns a list
    of frames containing, for each profile, whether there is
    agreement between the graphs.
    """
    list_of_frames = []
    graphs = [G1, G2]
    for graph in graphs:
        i = 0
        number_profiles = len(graph.nodes())
        # Get the adjacency matrix: it is easier to compute with it.
        P = nx.adjacency_matrix(graph)
        deviation_data = {}
        for node in graph.nodes():
            # An agent might wish to deviation forward (switch to a WF) or backward (switch to a WE)
            deviation_forward = 0
            deviation_backward = 0
            # Border cases: if all WF, then there is no going forward. Likewise, if all WE then there is no going backward.
            if i < number_profiles - 1:
                deviation_forward = P[i, i + 1]
            if i > 0:
                deviation_backward = P[i, i - 1]
            deviation_data[node] = (deviation_backward, deviation_forward)
            i = i + 1
        dataframe = pd.DataFrame.from_dict(deviation_data, orient='index')
        dataframe.columns = ['deviation_backward', 'deviation_forward']
        list_of_frames.append(dataframe)
    return list_of_frames

def agreement_data_to_dict(n1, n2, list_of_frames):
    """ 
    Converts a list of dataframes to a dictionary for ease of manipulation.
    """
    dataframe = pd.concat(list_of_frames, axis = 1)
    dataframe.columns = list(chain.from_iterable(('back_' + str(n),'forw_' + str(n)) for n in [n1, n2]))
    dataframe.loc[((dataframe['back_' + str(n1)] == dataframe['back_' + str(n2)]) & (dataframe['forw_' + str(n1)] == dataframe['forw_' + str(n2)])), str(n1)+ '-' + str(n2) + '-agreement'] = 1
    # By filling na with 0, we account for the case where the samples disagree.
    dataframe = dataframe.fillna(0)
    return dataframe.to_dict()

def determine_cascade_profile(number_of_games, number_of_agents, number_WE, number_WF, impressions, demand_factor):
    """
    Given an initial number of games, number_of_games, 
    cascades back to the first time the profile in 
    file_location is found. This function iteratively
    halfs number_of_games until a profile is found
    OR we get below 200, in which case an error is thrown.
    """
    while(number_of_games >= 100):
        zf = zipfile.ZipFile('../../results/' + str(number_of_games) + '.zip')
        file_location = setup.get_agent_dir_location(number_of_games, impressions, demand_factor) + 'WEWF(' + str(number_WE) + '-' + str(number_WF) + ').csv'
        print('Searching for ', file_location)
        if file_location in zf.namelist():
            print('\tFound!')
            return number_of_games
        else:
            print('\tNot found for number_of_games = ', number_of_games, ', trying half')
        number_of_games = int(number_of_games / 2)
    raise ValueError('******************* Could not find a sample for ', file_location)        

def compute_cascade_profile_data(number_of_games, number_of_agents, impressions, demand_factor):
    """
    This function will build a cascading graph, where we first look for 
    sample data with exactly number_of_games samples, and if we cannot find
    it, we try number_of_samples/2, and so on.
    If call with number_of_games = 100 OR number_of_games = 200, it 
    will find all samples by definition and thus return the graph where
    all the samples are 100 OR 200 respectively.
    """
    print('Computing cascade graph for number_of_games =', number_of_games, ', number_of_agents = ', number_of_agents, ', impressions = ', impressions, ', demand_factor = ', demand_factor)
    cascade_map_to_number_of_games = dict(('WE' * (number_of_agents-i) + 'WF' * i, determine_cascade_profile(number_of_games, number_of_agents,number_of_agents - i, i, impressions, demand_factor)) for i in range(0,number_of_agents + 1))
    return deviation_graphs.produce_specific_profile_data(cascade_map_to_number_of_games, number_of_agents, impressions, demand_factor)

def get_agreement_dataframe(n1, n2, number_of_agents, supply, demand):
    """
    Given number of samples n1, n2; number_of_agents, supply and demand,
    computes and the agreements between the cascades graphs generated by n1, n2
    and returns a dataframe with them.
    """
    DG_0_profile_data = compute_cascade_profile_data(n1, number_of_agents, supply, demand)
    DG_1_profile_data = compute_cascade_profile_data(n2, number_of_agents, supply, demand)
    DG_0 = deviation_graphs.produce_deviation_graph(DG_0_profile_data)
    DG_1 = deviation_graphs.produce_deviation_graph(DG_1_profile_data)
    deviation_n1_n2 = deviation_analysis.get_agreement_data(DG_0, DG_1)
    agreement_dict_n1_n2 = deviation_analysis.agreement_data_to_dict(n1, n2, deviation_n1_n2)
    agreement_dict_n1_n2 = agreement_dict_n1_n2[str(n1) + '-' + str(n2) + '-agreement']
    agreement_list = [(profile.count('WE'), profile.count('WF'), supply, demand, agreement_for_profile) for profile, agreement_for_profile in agreement_dict_n1_n2.items()]
    dataframe = pd.DataFrame(agreement_list)
    dataframe.columns = ['WE','WF','impressions','demand_factor', str(n1) + '-' + str(n2) + '-agreement']
    return dataframe

def save_agreement_data(n1, n2, number_of_agents):
    """
    Given number of samples n1, n2; and number_of_agents, saves the agreement data
    for all impressions and demand factors to a .csv file
    """
    list_of_dataframes = []
    print('Computing agreement data for ', number_of_agents, ' agents, between ', n1, ' and ', n2 ,' samples')
    for demand, impressions in setup.get_grid_demand_impressions():
        print('\t(demand_factor, impressions) = (', demand, ',', impressions, ')')
        list_of_dataframes += [get_agreement_dataframe(n1, n2, number_of_agents, impressions, demand)]
    final_dataframe = pd.concat(list_of_dataframes)
    final_dataframe.to_csv('../../stability/' + str(n1) + '-' + str(n2) + '/stability-for-' + str(number_of_agents) + '-agents.csv', index = False)